"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[922],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>k});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),p=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),c=p(n),d=a,k=c["".concat(l,".").concat(d)]||c[d]||u[d]||r;return n?o.createElement(k,i(i({ref:t},m),{},{components:n})):o.createElement(k,i({ref:t},m))}));function k(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:a,i[1]=s;for(var p=2;p<r;p++)i[p]=n[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7681:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var o=n(7462),a=(n(7294),n(3905));const r={id:"component-store",title:"Component Store",sidebar_label:"Component Store"},i=void 0,s={unversionedId:"component-store",id:"component-store",title:"Component Store",description:'MiniRx supports "local" state management with Component Store.',source:"@site/docs/component-store.md",sourceDirName:".",slug:"/component-store",permalink:"/docs/component-store",draft:!1,editUrl:"https://github.com/spierala/mini-rx-store/edit/master/docs/docs/component-store.md",tags:[],version:"current",frontMatter:{id:"component-store",title:"Component Store",sidebar_label:"Component Store"},sidebar:"docs",previous:{title:"Local Component State",permalink:"/docs/fs-config"},next:{title:"Quick Start",permalink:"/docs/ext-quick-start"}},l={},p=[{value:"Key Principles of Component Store",id:"key-principles-of-component-store",level:2},{value:"Use-cases",id:"use-cases",level:2},{value:"What&#39;s Included",id:"whats-included",level:2},{value:"Create a Component Store",id:"create-a-component-store",level:2},{value:"Option 1: Extend ComponentStore",id:"option-1-extend-componentstore",level:3},{value:"Option 2: Functional creation method",id:"option-2-functional-creation-method",level:3},{value:"Destroy",id:"destroy",level:2},{value:"Extensions",id:"extensions",level:2},{value:"Global extensions setup",id:"global-extensions-setup",level:3},{value:"Local extensions setup",id:"local-extensions-setup",level:3},{value:"Memoized selectors",id:"memoized-selectors",level:2},{value:"<code>createComponentStateSelector</code>",id:"createcomponentstateselector",level:3}],m={toc:p},c="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,o.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,'MiniRx supports "local" state management with ',(0,a.kt)("strong",{parentName:"p"},"Component Store"),".\nComponent Store allows you to manage state ",(0,a.kt)("strong",{parentName:"p"},"independently")," of the global state object (which is used by ",(0,a.kt)("a",{parentName:"p",href:"redux"},"Store")," and ",(0,a.kt)("a",{parentName:"p",href:"fs-quick-start"},"Feature Store"),")."),(0,a.kt)("h2",{id:"key-principles-of-component-store"},"Key Principles of Component Store"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Component Store has the ",(0,a.kt)("strong",{parentName:"li"},"same simple API as ",(0,a.kt)("a",{parentName:"strong",href:"fs-quick-start"},"Feature Store"))),(0,a.kt)("li",{parentName:"ul"},"Component Store state is ",(0,a.kt)("strong",{parentName:"li"},"independent")," of the global state object"),(0,a.kt)("li",{parentName:"ul"},"Component Store is ",(0,a.kt)("strong",{parentName:"li"},"destroyable"))),(0,a.kt)("h2",{id:"use-cases"},"Use-cases"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Local")," component state: ",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"State which is bound to a component"),(0,a.kt)("li",{parentName:"ul"},"State which has the lifespan of a component"),(0,a.kt)("li",{parentName:"ul"},"State which can exist multiple times (if the corresponding component exists multiple times)"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Frequent create/destroy:")," Creating and destroying Component Stores is fast"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Very frequent state changes")," could lead to performance issues when using ",(0,a.kt)("inlineCode",{parentName:"li"},"Store")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"FeatureStore"),"\n(both update the global state object using actions and reducers, which means more overhead)")),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Component Store is great for the mentioned use-cases. However, in most other cases you will be better off using MiniRx ",(0,a.kt)("a",{parentName:"p",href:"fs-quick-start"},"Feature Store"),":"),(0,a.kt)("ul",{parentName:"admonition"},(0,a.kt)("li",{parentName:"ul"},"Better debugging experience: Inspect Feature Store state with Redux DevTools"),(0,a.kt)("li",{parentName:"ul"},"Feature Store state can be more easily shared with other interested components/services (with ",(0,a.kt)("inlineCode",{parentName:"li"},"store.select()"),")"),(0,a.kt)("li",{parentName:"ul"},"Feature Store automatically uses the Store extensions (provided via ",(0,a.kt)("inlineCode",{parentName:"li"},"configureStore")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"StoreModule.forRoot")," in Angular). "),(0,a.kt)("li",{parentName:"ul"},"It is even possible to manage local state with Feature Stores (see ",(0,a.kt)("a",{parentName:"li",href:"fs-config"},"Local Component State with Feature Store"),").")),(0,a.kt)("p",{parentName:"admonition"},"But don't worry, your Component Store can be easily migrated to a Feature Store and vice versa!  ")),(0,a.kt)("h2",{id:"whats-included"},"What's Included"),(0,a.kt)("p",null,"The MiniRx ",(0,a.kt)("inlineCode",{parentName:"p"},"ComponentStore")," API:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"setState()")," update the state"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"setInitialState()")," initialize state lazily"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"select()")," select state as RxJS Observable"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"effect()")," run side effects like API calls and update state"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"undo()")," easily undo setState actions (requires the UndoExtension)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"destroy()")," clean up all internal Observable subscriptions (e.g. from effects)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"tapResponse")," operator: handle the response in Component Store ",(0,a.kt)("inlineCode",{parentName:"li"},"effect")," consistently and with less boilerplate")),(0,a.kt)("p",null,"Since the API of ",(0,a.kt)("inlineCode",{parentName:"p"},"ComponentStore")," is identical to ",(0,a.kt)("inlineCode",{parentName:"p"},"FeatureStore"),", please refer to the\n",(0,a.kt)("a",{parentName:"p",href:"fs-quick-start"},"Feature Store docs")," for more details. "),(0,a.kt)("h2",{id:"create-a-component-store"},"Create a Component Store"),(0,a.kt)("p",null,"There are 2 Options to create a new Component Store."),(0,a.kt)("h3",{id:"option-1-extend-componentstore"},"Option 1: Extend ComponentStore"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Observable } from 'rxjs';\nimport { ComponentStore } from 'mini-rx-store';\n\ninterface CounterState {\n    count: number;\n}\n\nconst initialState: CounterState = {\n    count: 42,\n};\n\nexport class CounterStore extends ComponentStore<CounterState> {\n  count$: Observable<number> = this.select((state) => state.count);\n\n  constructor() {\n    super(initialState);\n  }\n\n  increment() {\n    this.setState(state => ({ count: state.count + 1 }));\n  }\n\n  decrement() {\n    this.setState(state => ({ count: state.count - 1 }));\n  }\n}\n")),(0,a.kt)("h3",{id:"option-2-functional-creation-method"},"Option 2: Functional creation method"),(0,a.kt)("p",null,"We can create a Component Store with ",(0,a.kt)("inlineCode",{parentName:"p"},"createComponentStore"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { ComponentStore, createComponentStore } from 'mini-rx-store';\n\nconst counterCs: ComponentStore<CounterState> = createComponentStore<CounterState>(initialState);\n")),(0,a.kt)("h2",{id:"destroy"},"Destroy"),(0,a.kt)("admonition",{type:"warning"},(0,a.kt)("p",{parentName:"admonition"},"If you manage local component state with Component Store..., please make sure to destroy the Component Store when the corresponding component is destroyed! ")),(0,a.kt)("p",null,"You can destroy a Component Store with the ",(0,a.kt)("inlineCode",{parentName:"p"},"destroy")," method. The ",(0,a.kt)("inlineCode",{parentName:"p"},"destroy")," method will unsubscribe all internal RxJS subscriptions (e.g. from effects)."),(0,a.kt)("p",null,"The Component Store ",(0,a.kt)("inlineCode",{parentName:"p"},"destroy")," method follows the same principles as the ",(0,a.kt)("inlineCode",{parentName:"p"},"destroy")," method of Feature Store. Read more in the ",(0,a.kt)("a",{parentName:"p",href:"/docs/fs-config#destroy"},'Feature Store "Destroy" docs'),"."),(0,a.kt)("h2",{id:"extensions"},"Extensions"),(0,a.kt)("p",null,"You can use most of the ",(0,a.kt)("a",{parentName:"p",href:"ext-quick-start"},"MiniRx extensions")," with the Component Store."),(0,a.kt)("p",null,"Extensions with Component Store support:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Immutable Extension: Enforce state immutability"),(0,a.kt)("li",{parentName:"ul"},"Undo Extension: Undo state changes from ",(0,a.kt)("inlineCode",{parentName:"li"},"setState")),(0,a.kt)("li",{parentName:"ul"},'Logger Extension: console.log the current "setState" action and updated state')),(0,a.kt)("p",null,"It's possible to configure the Component Store extensions globally or individually for each Component Store instance."),(0,a.kt)("h3",{id:"global-extensions-setup"},"Global extensions setup"),(0,a.kt)("p",null,"Configure extensions globally for every Component Store with the ",(0,a.kt)("inlineCode",{parentName:"p"},"configureComponentStores")," function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import {\n  configureComponentStores,\n} from 'mini-rx-store';\n\nconfigureComponentStores({\n  extensions: [new ImmutableStateExtension()]\n});\n")),(0,a.kt)("p",null,"Now every Component Store instance will have the ImmutableStateExtension. "),(0,a.kt)("h3",{id:"local-extensions-setup"},"Local extensions setup"),(0,a.kt)("p",null,"Configure extensions individually via the Component Store configuration object:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import { ComponentStore, LoggerExtension } from 'mini-rx-store';\n\nexport class CounterStore extends ComponentStore<CounterState> {\n  constructor() {\n    super(initialState, {\n      extensions: [ new LoggerExtension() ]\n    });\n  }\n}\n")),(0,a.kt)("p",null,'"Local" extensions are merged with the (global) extensions from ',(0,a.kt)("inlineCode",{parentName:"p"},"configureComponentStores"),".\nTherefore, every ",(0,a.kt)("inlineCode",{parentName:"p"},"CounterStore")," instance will have the LoggerExtension (from the local extension setup) ",(0,a.kt)("strong",{parentName:"p"},"and")," the\nImmutableStateExtension (from the ",(0,a.kt)("inlineCode",{parentName:"p"},"configureComponentStores")," extensions)."),(0,a.kt)("p",null,"If an extension is defined globally and locally, then only the local extension is used."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"It makes sense to add the ImmutableStateExtension to ",(0,a.kt)("inlineCode",{parentName:"p"},"configureComponentStores")," (",(0,a.kt)("a",{parentName:"p",href:"#global-extensions-setup"},'"Global extensions setup"'),").\nLike this, every Component Store can benefit from immutable state."),(0,a.kt)("p",{parentName:"admonition"},"The LoggerExtension can be added to individual Component Stores for debugging purposes (",(0,a.kt)("a",{parentName:"p",href:"#local-extensions-setup"},'"Local extensions setup"'),")."),(0,a.kt)("p",{parentName:"admonition"},"Regarding the ",(0,a.kt)("inlineCode",{parentName:"p"},"undo")," API: It is recommended to add the UndoExtension to the Component Stores which need the undo functionality (",(0,a.kt)("a",{parentName:"p",href:"#local-extensions-setup"},'"Local extensions setup"'),"). ")),(0,a.kt)("h2",{id:"memoized-selectors"},"Memoized selectors"),(0,a.kt)("p",null,"Of course, you can use memoized selectors also with Component Store! "),(0,a.kt)("h3",{id:"createcomponentstateselector"},(0,a.kt)("inlineCode",{parentName:"h3"},"createComponentStateSelector")),(0,a.kt)("p",null,"You can use ",(0,a.kt)("inlineCode",{parentName:"p"},"createComponentStateSelector")," together with ",(0,a.kt)("inlineCode",{parentName:"p"},"createSelector")," to create your selector functions."),(0,a.kt)("p",null,"Example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"// Memoized Selectors\nconst getComponentState = createComponentStateSelector<TodoState>();\n\nconst getTodos = createSelector(\n  getComponentState,\n  state => state.todos\n);\n\nconst getSelectedTodoId = createSelector(\n  getComponentState,\n  state => state.selectedTodoId\n)\n\nconst getSelectedTodo = createSelector(\n  getTodos,\n  getSelectedTodoId,\n  (todos, id) => todos.find(item => item.id === id)\n)\n\nclass TodoStore extends ComponentStore<TodoState> {\n\n  // State Observables\n  todoState$: Observable<TodoState> = this.select(getComponentState);\n  todos$: Observable<Todo[]> = this.select(getTodos);\n  selectedTodo$: Observable<Todo> = this.select(getSelectedTodo);\n\n  constructor() {\n    super(initialState)\n  }\n}\n")))}u.isMDXComponent=!0}}]);